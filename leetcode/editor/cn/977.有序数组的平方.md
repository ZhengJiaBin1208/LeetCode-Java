# [977.有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

## 难度 

<font color=*green*>简单</font>

## 题目

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。



### 示例

#### 示例 1：

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```



#### 示例 2：

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```



### 提示：

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按 **非递减顺序** 排序

### 进阶：

- 请你设计时间复杂度为 `O(n)` 的算法解决本问题

## 解题思路

### 创建时间：

2021年12月14日14:43:06



### 解法：

#### 暴力解法：

增加新数组，循环取乘积加入新数组，新数组排序，返回新数组

**复杂度分析**

- 时间复杂度：O(n log n)，其中 n 是数组 nums 的长度。
- 空间复杂度：O(log n)。除了存储答案的数组以外，我们需要O(log n) 的栈空间进行排序。

![977(1)](D:/leetcode/resources/image/977(1).png)

#### 双指针：

左指针从0向n-1滑动，右指针从n-1向0滑动，新数组从n-1向0填充数字，如果左指针下标数值乘积大于右指针下标数值乘积，则新数组n-1下标数值为左下标数值乘积，反之是右下标数值乘积，每次新数组向左滑动一次

**复杂度分析**

- 时间复杂度：O(n)，其中 n 是数组nums的长度。
- 空间复杂度：O(1)。除了存储答案的数组以外，我们只需要维护常量空间。
![977(2)](D:/leetcode/resources/image/977(2).png)

#### 程序逻辑

1.获取原数组长度为n

2.声明新数组长度为n

3.循环中声明左指针为0，右指针为n-1，新数组填充下标为n-1，循环条件为左指针小于等于右指针

4.判断左指针下标数值乘积是否小于右指针下标数值乘积
	左指针下标乘积大于右指针下标数值乘积，新数组填充为左下标数值乘积
	左指针下标乘积小于右指针下标数值乘积，新数组填充为右下标数值乘积
5.新数组填充一次左移一位

## 代码

```java
class Solution {
    public int[] sortedSquares(int[] A) {
        int n = A.length;
        int[] B = new int[n];
        for (int i = 0,j = n - 1,index = n - 1;i <= j;) {
            if(A[i] * A[i] > A[j] * A[j]){
                B[index] = A[i] * A[i];
                i++;
            }else{
                B[index] = A[j] * A[j];
                j--;
            }
            index--;
        }
        return B;
    }
}
```

