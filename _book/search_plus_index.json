{"./":{"url":"./","title":"LeetCode-Java","keywords":"","body":"LeetCode-Java 前言 Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 10:53:51 "},"leetcode/":{"url":"leetcode/","title":"leetcode","keywords":"","body":"leetcode Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-26 15:09:56 "},"leetcode/editor/":{"url":"leetcode/editor/","title":"editor","keywords":"","body":"editor Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-26 15:09:56 "},"leetcode/editor/cn/":{"url":"leetcode/editor/cn/","title":"cn","keywords":"","body":"cn Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-26 15:09:56 "},"leetcode/editor/cn/[1]两数之和.html":{"url":"leetcode/editor/cn/[1]两数之和.html","title":"[1]两数之和","keywords":"","body":"[1] 两数之和 题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 示例 1 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 示例 2 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3 输入：nums = [3,3], target = 6 输出：[0,1] 提示 2 解题思路 这道题最优的做法时间复杂度是 O(n)。 2019/01/17 19:13 目前给出的是暴力双重for循环算法，时间复杂度为 O(n^2^)。 代码 class Solution { public int[] twoSum(int[] nums, int target) { for(int i = 0; i Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 14:24:40 "},"leetcode/editor/cn/[2]两数相加.html":{"url":"leetcode/editor/cn/[2]两数相加.html","title":"[2]两数相加","keywords":"","body":"[2]两数相加 Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 11:46:12 "},"leetcode/editor/cn/[3]无重复字符的最长子串.html":{"url":"leetcode/editor/cn/[3]无重复字符的最长子串.html","title":"[3]无重复字符的最长子串","keywords":"","body":"[3] 无重复字符的最长子串 题目 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 示例 1 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 示例 4 输入: s = \"\" 输出: 0 提示 0 解题思路 这道题最优的做法时间复杂度是 O(n)。 2018/12/15 21:48 目前给出的是暴力双重for循环算法，时间复杂度为 O(n^2^)。 代码 class Solution { public int[] twoSum(int[] nums, int target) { int []hash = new int [500]; int max = 0; int i = 0, j = 0; while (i max ? (j - i) : max; } else { hash[s.charAt(i)] = 0; i++; } } return max; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-26 16:00:33 "},"leetcode/editor/cn/35.搜索插入位置.html":{"url":"leetcode/editor/cn/35.搜索插入位置.html","title":"35.搜索插入位置","keywords":"","body":"35.搜索插入位置 题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 示例 4: 输入: nums = [1,3,5,6], target = 0 输出: 0 示例 5: 输入: nums = [1], target = 0 输出: 0 提示: 1 -10^4^ nums 为无重复元素的升序排列数组 -10^4^ 解题思路 2021年11月30日16:39:49 解法： 二分查找： 设置左右边界，二分取中间值和目标值比较，如果等于目标值返回中间值下标值，如果目标值大于中间值，左边界右移到中间值加1位置，反之右边界左移到中间值-1位置，当左边界小于右边界时，返回左边界 时间复杂度 O(logn)，其中n是数组长度，beats 100%。 程序逻辑 1.设置初始左右边界为0，数组长度 2.设置中间值下标为右边界减去左边界除2加上左边界 3.通过中间值下标取出中间值 4.目标值和中间值比较 1)相等，返回目标值下标 2)目标值大于中间值，左边界等于中间值下标+1 3)目标值小于中间值，右边界等于中间值下标-1 5.退出循环时，返回左边界 代码 class Solution { public int searchInsert(int[] nums, int target) { int left = 0,right=nums.length-1; while(left num){ left = mid + 1; }else{ right = mid - 1; } } return left; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 16:49:06 "},"leetcode/editor/cn/278.第一个错误的版本.html":{"url":"leetcode/editor/cn/278.第一个错误的版本.html","title":"278.第一个错误的版本","keywords":"","body":"278.第一个错误的版本 题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 示例 1： 输入：n = 5, bad = 4 输出：4 解释： 调用 isBadVersion(3) -> false 调用 isBadVersion(5) -> true 调用 isBadVersion(4) -> true 所以，4 是第一个错误的版本。 示例 2： 输入：n = 1, bad = 1 输出：1 提示： 1 解题思路 2021年11月30日16:09:12 解法： 二分查找： 设置左右边界，二分取中间值，如果中间值调用函数返回为true，说明错误版本在中间值左边，则右边界等于中间值，反之说明错误版本在中间值右边，则左边界等于中间值+1 时间复杂度 O(logn)，其中n是数组长度，beats 100%。 程序逻辑 1.设置初始左右边界为1，输入数字长度 2.设置中间值下标为右边界减去左边界除2加上左边界 3.目标值和中间值比较 1)调用结果返回为true，说明错误版本在左边界与中间值之间，右边界等于中间值 2)调用结果返回为false，说明错误版本在中间值与右边界之间，左边界等于中间值+1 5.循环之后左右边界重合，返回左边界 代码 /* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */ public class Solution extends VersionControl { public int firstBadVersion(int n) { int left =1,right = n; while(left Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 16:48:51 "},"leetcode/editor/cn/704.二分查找.html":{"url":"leetcode/editor/cn/704.二分查找.html","title":"704.二分查找","keywords":"","body":"704.二分查找 题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 1.你可以假设 nums 中的所有元素是不重复的。 2.n 将在 [1, 10000]之间。 3.nums 的每个元素都将在 [-9999, 9999]之间。 解题思路 2021年11月30日14:57:28 解法1： 暴力解法，for循环找到相等返回下标，找不到返回-1。 时间复杂度是 O(n)，其中n是数组长度，beats 30%。 解法2： 二分查找： 设置左右边界，二分取中间值和目标值比较，如果等于目标值返回中间值下标值，如果目标值大于中间值，左边界右移到中间值加1位置，反之右边界左移到中间值-1位置，当左边界小于右边界时，说明数组中没有目标值，返回-1 时间复杂度 O(logn)，其中n是数组长度，beats 100%。 程序逻辑 1.设置初始左右边界为0，数组长度 2.设置中间值下标为右边界减去左边界除2加上左边界 3.通过中间值下标取出中间值 4.目标值和中间值比较 1)相等，返回目标值下标 2)目标值大于中间值，左边界等于中间值下标+1 3)目标值小于中间值，右边界等于中间值下标-1 5.左边界小于右边界还找不到目标值时，返回-1 代码 class Solution { public int search(int[] nums, int target) { int left = 0,right=nums.length-1; while(left num){ left = mid + 1; }else{ right = mid - 1; } } return -1; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 16:48:41 "}}