{"./":{"url":"./","title":"LeetCode-Java","keywords":"","body":"LeetCode-Java 前言 Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 10:53:51 "},"leetcode/":{"url":"leetcode/","title":"leetcode","keywords":"","body":"leetcode Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-26 15:09:56 "},"leetcode/editor/":{"url":"leetcode/editor/","title":"editor","keywords":"","body":"editor Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-26 15:09:56 "},"leetcode/editor/cn/":{"url":"leetcode/editor/cn/","title":"cn","keywords":"","body":"cn Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-26 15:09:56 "},"leetcode/editor/cn/[1]两数之和.html":{"url":"leetcode/editor/cn/[1]两数之和.html","title":"[1]两数之和","keywords":"","body":"[1] 两数之和 题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 示例 1 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 示例 2 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3 输入：nums = [3,3], target = 6 输出：[0,1] 提示 2 解题思路 这道题最优的做法时间复杂度是 O(n)。 2019/01/17 19:13 目前给出的是暴力双重for循环算法，时间复杂度为 O(n^2^)。 代码 class Solution { public int[] twoSum(int[] nums, int target) { for(int i = 0; i Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 14:24:40 "},"leetcode/editor/cn/[2]两数相加.html":{"url":"leetcode/editor/cn/[2]两数相加.html","title":"[2]两数相加","keywords":"","body":"[2]两数相加 Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 11:46:12 "},"leetcode/editor/cn/[3]无重复字符的最长子串.html":{"url":"leetcode/editor/cn/[3]无重复字符的最长子串.html","title":"[3]无重复字符的最长子串","keywords":"","body":"[3] 无重复字符的最长子串 题目 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 示例 1 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 示例 4 输入: s = \"\" 输出: 0 提示 0 解题思路 这道题最优的做法时间复杂度是 O(n)。 2018/12/15 21:48 目前给出的是暴力双重for循环算法，时间复杂度为 O(n^2^)。 代码 class Solution { public int[] twoSum(int[] nums, int target) { int []hash = new int [500]; int max = 0; int i = 0, j = 0; while (i max ? (j - i) : max; } else { hash[s.charAt(i)] = 0; i++; } } return max; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-26 16:00:33 "},"leetcode/editor/cn/35.搜索插入位置.html":{"url":"leetcode/editor/cn/35.搜索插入位置.html","title":"35.搜索插入位置","keywords":"","body":"35.搜索插入位置 题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 示例 4: 输入: nums = [1,3,5,6], target = 0 输出: 0 示例 5: 输入: nums = [1], target = 0 输出: 0 提示: 1 -10^4^ nums 为无重复元素的升序排列数组 -10^4^ 解题思路 2021年11月30日16:39:49 解法： 二分查找： 设置左右边界，二分取中间值和目标值比较，如果等于目标值返回中间值下标值，如果目标值大于中间值，左边界右移到中间值加1位置，反之右边界左移到中间值-1位置，当左边界小于右边界时，返回左边界 时间复杂度 O(logn)，其中n是数组长度，beats 100%。 程序逻辑 1.设置初始左右边界为0，数组长度 2.设置中间值下标为右边界减去左边界除2加上左边界 3.通过中间值下标取出中间值 4.目标值和中间值比较 1)相等，返回目标值下标 2)目标值大于中间值，左边界等于中间值下标+1 3)目标值小于中间值，右边界等于中间值下标-1 5.退出循环时，返回左边界 代码 class Solution { public int searchInsert(int[] nums, int target) { int left = 0,right=nums.length-1; while(left num){ left = mid + 1; }else{ right = mid - 1; } } return left; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 16:49:06 "},"leetcode/editor/cn/167.两数之和 II - 输入有序数组.html":{"url":"leetcode/editor/cn/167.两数之和 II - 输入有序数组.html","title":"167.两数之和 II - 输入有序数组","keywords":"","body":"167. 两数之和 II - 输入有序数组 难度 简单 题目 给定一个已按照 非递减顺序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 。 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。 示例 示例 1： 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 示例 2： 输入：numbers = [2,3,4], target = 6 输出：[1,3] 示例 3： 输入：numbers = [-1,0], target = -1 输出：[1,2] 提示： 2 -1000 numbers 按 非递减顺序 排列 -1000 仅存在一个有效答案 解题思路 创建时间： 2021年12月16日11:00:29 解法： 双指针： 左指针数组值+ 右指针数组值 的和与target作比较 小于 左指针右移 大于 右指针左移 等于 返回左右指针 加1数组 复杂度分析 时间复杂度：O(n)，其中 n 是数组的长度。两个指针移动的总次数最多为 n次。 空间复杂度：O(1)。除了存储答案的数组以外，我们只需要维护常量空间。 程序逻辑 1.声明左指针为0，右指针为数组长度-1 2.声明新数组长度为n 3.循环中声明左指针为0，右指针为n-1，新数组填充下标为n-1，循环条件为左指针小于等于右指针 4.判断左指针下标数值乘积是否小于右指针下标数值乘积 左指针下标乘积大于右指针下标数值乘积，新数组填充为左下标数值乘积 左指针下标乘积小于右指针下标数值乘积，新数组填充为右下标数值乘积 5.新数组填充一次左移一位 代码 class Solution { public int[] twoSum(int[] numbers, int target) { /** * 解法:双指针，左指针数组值+ 右指针数组值 的和与target作比较 * 小于 左指针右移 * 大于 右指针左移 * 等于 返回左右指针 加1数组 */ int left = 0,right = numbers.length-1; while (left Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-12-16 11:15:51 "},"leetcode/editor/cn/189.轮转数组.html":{"url":"leetcode/editor/cn/189.轮转数组.html","title":"189.轮转数组","keywords":"","body":"[189.轮转数组 难度 中等 题目 给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 示例 1： 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2： 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] 提示： 1 -231 0 进阶： 尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 解题思路 2021年12月7日16:49:50 解法： 双指针： 增加新数组，通过取余方式给新数组赋值 复杂度分析 时间复杂度： O(n)，其中 n 为数组的长度。 空间复杂度： O(n)。 程序逻辑 1.获取原数组长度 2.引用数组赋默认值 3.循环原数组，原数组当前位置上的值为引用数组当前索引(i+k)%n 4.引用数组值复制给原数组 代码 class Solution { public void rotate(int[] nums, int k) { int n = nums.length; int[] newArr = new int[n]; for (int i = 0; i Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-12-15 17:24:14 "},"leetcode/editor/cn/278.第一个错误的版本.html":{"url":"leetcode/editor/cn/278.第一个错误的版本.html","title":"278.第一个错误的版本","keywords":"","body":"278.第一个错误的版本 题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 示例 1： 输入：n = 5, bad = 4 输出：4 解释： 调用 isBadVersion(3) -> false 调用 isBadVersion(5) -> true 调用 isBadVersion(4) -> true 所以，4 是第一个错误的版本。 示例 2： 输入：n = 1, bad = 1 输出：1 提示： 1 解题思路 2021年11月30日16:09:12 解法： 二分查找： 设置左右边界，二分取中间值，如果中间值调用函数返回为true，说明错误版本在中间值左边，则右边界等于中间值，反之说明错误版本在中间值右边，则左边界等于中间值+1 时间复杂度 O(logn)，其中n是数组长度，beats 100%。 程序逻辑 1.设置初始左右边界为1，输入数字长度 2.设置中间值下标为右边界减去左边界除2加上左边界 3.目标值和中间值比较 1)调用结果返回为true，说明错误版本在左边界与中间值之间，右边界等于中间值 2)调用结果返回为false，说明错误版本在中间值与右边界之间，左边界等于中间值+1 5.循环之后左右边界重合，返回左边界 代码 /* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */ public class Solution extends VersionControl { public int firstBadVersion(int n) { int left =1,right = n; while(left Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 16:48:51 "},"leetcode/editor/cn/283.移动零.html":{"url":"leetcode/editor/cn/283.移动零.html","title":"283.移动零","keywords":"","body":"283.移动零](https://leetcode-cn.com/problems/move-zeroes/) 难度 简单 题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例 示例 1： 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路 创建时间： 2021年12月15日17:53:00 解法： 双指针： 左指针找到0的位置，右指针定位到非0位置和左指针位置交换 复杂度分析 时间复杂度：O(n)，其中 n为序列长度。每个位置至多被遍历两次。 空间复杂度：O(1)。只需要常数的空间存放若干变量。 程序逻辑 1.定义左右指针从0开始，循环条件为右指针小于数组长度 2.右指针每次循环都向前移动 3.当右指针指向出不为0时候，左右指针值交换，左指针向前移动 代码 class Solution { public void moveZeroes(int[] nums) { for (int i = 0,j = 0;i Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-12-15 18:05:37 "},"leetcode/editor/cn/704.二分查找.html":{"url":"leetcode/editor/cn/704.二分查找.html","title":"704.二分查找","keywords":"","body":"704.二分查找 题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 1.你可以假设 nums 中的所有元素是不重复的。 2.n 将在 [1, 10000]之间。 3.nums 的每个元素都将在 [-9999, 9999]之间。 解题思路 2021年11月30日14:57:28 解法1： 暴力解法，for循环找到相等返回下标，找不到返回-1。 时间复杂度是 O(n)，其中n是数组长度，beats 30%。 解法2： 二分查找： 设置左右边界，二分取中间值和目标值比较，如果等于目标值返回中间值下标值，如果目标值大于中间值，左边界右移到中间值加1位置，反之右边界左移到中间值-1位置，当左边界小于右边界时，说明数组中没有目标值，返回-1 时间复杂度 O(logn)，其中n是数组长度，beats 100%。 程序逻辑 1.设置初始左右边界为0，数组长度 2.设置中间值下标为右边界减去左边界除2加上左边界 3.通过中间值下标取出中间值 4.目标值和中间值比较 1)相等，返回目标值下标 2)目标值大于中间值，左边界等于中间值下标+1 3)目标值小于中间值，右边界等于中间值下标-1 5.左边界小于右边界还找不到目标值时，返回-1 代码 class Solution { public int search(int[] nums, int target) { int left = 0,right=nums.length-1; while(left num){ left = mid + 1; }else{ right = mid - 1; } } return -1; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 16:48:41 "},"leetcode/editor/cn/977.有序数组的平方.html":{"url":"leetcode/editor/cn/977.有序数组的平方.html","title":"977.有序数组的平方","keywords":"","body":"977.有序数组的平方 难度 简单 题目 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 -104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 解题思路 创建时间： 2021年12月14日14:43:06 解法： 暴力解法： 增加新数组，循环取乘积加入新数组，新数组排序，返回新数组 复杂度分析 时间复杂度：O(n log n)，其中 n 是数组 nums 的长度。 空间复杂度：O(log n)。除了存储答案的数组以外，我们需要O(log n) 的栈空间进行排序。 .png) 双指针： 左指针从0向n-1滑动，右指针从n-1向0滑动，新数组从n-1向0填充数字，如果左指针下标数值乘积大于右指针下标数值乘积，则新数组n-1下标数值为左下标数值乘积，反之是右下标数值乘积，每次新数组向左滑动一次 复杂度分析 时间复杂度：O(n)，其中 n 是数组nums的长度。 空间复杂度：O(1)。除了存储答案的数组以外，我们只需要维护常量空间。 .png) 程序逻辑 1.获取原数组长度为n 2.声明新数组长度为n 3.循环中声明左指针为0，右指针为n-1，新数组填充下标为n-1，循环条件为左指针小于等于右指针 4.判断左指针下标数值乘积是否小于右指针下标数值乘积 左指针下标乘积大于右指针下标数值乘积，新数组填充为左下标数值乘积 左指针下标乘积小于右指针下标数值乘积，新数组填充为右下标数值乘积 5.新数组填充一次左移一位 代码 class Solution { public int[] sortedSquares(int[] A) { int n = A.length; int[] B = new int[n]; for (int i = 0,j = n - 1,index = n - 1;i A[j] * A[j]){ B[index] = A[i] * A[i]; i++; }else{ B[index] = A[j] * A[j]; j--; } index--; } return B; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-12-15 16:14:56 "}}