{"./":{"url":"./","title":"LeetCode-Java","keywords":"","body":"LeetCode-Java 前言 Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 10:53:51 "},"leetcode/":{"url":"leetcode/","title":"leetcode","keywords":"","body":"leetcode Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-26 15:09:56 "},"leetcode/1.两数之和.html":{"url":"leetcode/1.两数之和.html","title":"1.两数之和","keywords":"","body":"1.两数之和 题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 示例 1 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 示例 2 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3 输入：nums = [3,3], target = 6 输出：[0,1] 提示 2 解题思路 这道题最优的做法时间复杂度是 O(n)。 2019/01/17 19:13 目前给出的是暴力双重for循环算法，时间复杂度为 O(n^2^)。 代码 class Solution { public int[] twoSum(int[] nums, int target) { for(int i = 0; i Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2022-01-07 10:46:26 "},"leetcode/3.无重复字符的最长子串.html":{"url":"leetcode/3.无重复字符的最长子串.html","title":"3.无重复字符的最长子串","keywords":"","body":"3.无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) 难度 中等 题目 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 示例 1： 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2： 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3： 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 示例 4： 输入: s = \"\" 输出: 0 提示： 0 s 由英文字母、数字、符号和空格组成 解题思路 创建时间: 2021年12月21日10:30:34 解法： 滑动窗口： 128位数组用来占位，右侧窗口如果当前字母在当前位置上为0，则设置位置为1，右边界向右滑动，最大值判断右边界减左边界是否比之前最长子串长度长，如果长最大长度为右边界减左边界，如果不长则最大长度值不变，当前字符如果在当前位置为1，则左侧窗口向右滑动 复杂度分析 时间复杂度： O(N)，其中 N是字符串的长度。左指针和右指针分别会遍历整个字符串一次。 空间复杂度： O(∣Σ∣)，其中Σ 表示字符集（即字符串中可以出现的字符），∣Σ∣ 表示字符集的大小。在 本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)内的字符，即∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有∣Σ∣ 个，因此空间复杂度为O(∣Σ∣)。 程序逻辑 1.生成所有ASCII编码128位占位符，最长字符串计数器max，滑动窗口左边界为0，滑动窗口右边界为0 2.循环滑动窗口左右边界都小于字符长度 3.判断右边界当前字符串字符是否为0， 如果为0，在当前占位上设置为1，右边界向右滑动1位，判断最长字符串计数器是否大于右边界减左边界，大于计数器取右边界减左边界，反之取原值 如果不为0，设置当前占位为0，窗口左边界向右滑动 4.返回最长字符串计数器的值 代码 class Solution { public int lengthOfLongestSubstring(String s) { int []hash = new int [128]; int max = 0; int i = 0, j = 0; while (i max ? (j - i) : max; } else { hash[s.charAt(i)] = 0; i++; } } return max; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-12-21 15:43:33 "},"leetcode/35.搜索插入位置.html":{"url":"leetcode/35.搜索插入位置.html","title":"35.搜索插入位置","keywords":"","body":"35.搜索插入位置 题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 示例 4: 输入: nums = [1,3,5,6], target = 0 输出: 0 示例 5: 输入: nums = [1], target = 0 输出: 0 提示: 1 -10^4^ nums 为无重复元素的升序排列数组 -10^4^ 解题思路 2021年11月30日16:39:49 解法： 二分查找： 设置左右边界，二分取中间值和目标值比较，如果等于目标值返回中间值下标值，如果目标值大于中间值，左边界右移到中间值加1位置，反之右边界左移到中间值-1位置，当左边界小于右边界时，返回左边界 时间复杂度 O(logn)，其中n是数组长度，beats 100%。 程序逻辑 1.设置初始左右边界为0，数组长度 2.设置中间值下标为右边界减去左边界除2加上左边界 3.通过中间值下标取出中间值 4.目标值和中间值比较 1)相等，返回目标值下标 2)目标值大于中间值，左边界等于中间值下标+1 3)目标值小于中间值，右边界等于中间值下标-1 5.退出循环时，返回左边界 代码 class Solution { public int searchInsert(int[] nums, int target) { int left = 0,right=nums.length-1; while(left num){ left = mid + 1; }else{ right = mid - 1; } } return left; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 16:49:06 "},"leetcode/167.两数之和 II - 输入有序数组.html":{"url":"leetcode/167.两数之和 II - 输入有序数组.html","title":"167.两数之和 II - 输入有序数组","keywords":"","body":"167. 两数之和 II - 输入有序数组 难度 简单 题目 给定一个已按照 非递减顺序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 。 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。 示例 示例 1： 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 示例 2： 输入：numbers = [2,3,4], target = 6 输出：[1,3] 示例 3： 输入：numbers = [-1,0], target = -1 输出：[1,2] 提示： 2 -1000 numbers 按 非递减顺序 排列 -1000 仅存在一个有效答案 解题思路 创建时间： 2021年12月16日11:00:29 解法： 双指针： 左指针数组值+ 右指针数组值 的和与target作比较 小于 左指针右移 大于 右指针左移 等于 返回左右指针 加1数组 复杂度分析 时间复杂度：O(n)，其中 n 是数组的长度。两个指针移动的总次数最多为 n次。 空间复杂度：O(1)。除了存储答案的数组以外，我们只需要维护常量空间。 程序逻辑 1.声明左指针为0，右指针为数组长度-1 2.声明新数组长度为n 3.循环中声明左指针为0，右指针为n-1，新数组填充下标为n-1，循环条件为左指针小于等于右指针 4.判断左指针下标数值乘积是否小于右指针下标数值乘积 左指针下标乘积大于右指针下标数值乘积，新数组填充为左下标数值乘积 左指针下标乘积小于右指针下标数值乘积，新数组填充为右下标数值乘积 5.新数组填充一次左移一位 代码 class Solution { public int[] twoSum(int[] numbers, int target) { /** * 解法:双指针，左指针数组值+ 右指针数组值 的和与target作比较 * 小于 左指针右移 * 大于 右指针左移 * 等于 返回左右指针 加1数组 */ int left = 0,right = numbers.length-1; while (left Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-12-16 11:15:51 "},"leetcode/189.轮转数组.html":{"url":"leetcode/189.轮转数组.html","title":"189.轮转数组","keywords":"","body":"[189.轮转数组 难度 中等 题目 给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 示例 1： 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2： 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] 提示： 1 -231 0 进阶： 尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 解题思路 2021年12月7日16:49:50 解法： 双指针： 增加新数组，通过取余方式给新数组赋值 复杂度分析 时间复杂度： O(n)，其中 n 为数组的长度。 空间复杂度： O(n)。 程序逻辑 1.获取原数组长度 2.引用数组赋默认值 3.循环原数组，原数组当前位置上的值为引用数组当前索引(i+k)%n 4.引用数组值复制给原数组 代码 class Solution { public void rotate(int[] nums, int k) { int n = nums.length; int[] newArr = new int[n]; for (int i = 0; i Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2022-01-10 11:38:19 "},"leetcode/278.第一个错误的版本.html":{"url":"leetcode/278.第一个错误的版本.html","title":"278.第一个错误的版本","keywords":"","body":"278.第一个错误的版本 题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例 示例 1： 输入：n = 5, bad = 4 输出：4 解释： 调用 isBadVersion(3) -> false 调用 isBadVersion(5) -> true 调用 isBadVersion(4) -> true 所以，4 是第一个错误的版本。 示例 2： 输入：n = 1, bad = 1 输出：1 提示： 1 解题思路 2021年11月30日16:09:12 解法： 二分查找： 设置左右边界，二分取中间值，如果中间值调用函数返回为true，说明错误版本在中间值左边，则右边界等于中间值，反之说明错误版本在中间值右边，则左边界等于中间值+1 时间复杂度 O(logn)，其中n是数组长度，beats 100%。 程序逻辑 1.设置初始左右边界为1，输入数字长度 2.设置中间值下标为右边界减去左边界除2加上左边界 3.目标值和中间值比较 1)调用结果返回为true，说明错误版本在左边界与中间值之间，右边界等于中间值 2)调用结果返回为false，说明错误版本在中间值与右边界之间，左边界等于中间值+1 5.循环之后左右边界重合，返回左边界 代码 /* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */ public class Solution extends VersionControl { public int firstBadVersion(int n) { int left =1,right = n; while(left Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 16:48:51 "},"leetcode/283.移动零.html":{"url":"leetcode/283.移动零.html","title":"283.移动零","keywords":"","body":"283.移动零](https://leetcode-cn.com/problems/move-zeroes/) 难度 简单 题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例 示例 1： 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路 创建时间： 2021年12月15日17:53:00 解法： 双指针： 左指针找到0的位置，右指针定位到非0位置和左指针位置交换 复杂度分析 时间复杂度：O(n)，其中 n为序列长度。每个位置至多被遍历两次。 空间复杂度：O(1)。只需要常数的空间存放若干变量。 程序逻辑 1.定义左右指针从0开始，循环条件为右指针小于数组长度 2.右指针每次循环都向前移动 3.当右指针指向出不为0时候，左右指针值交换，左指针向前移动 代码 class Solution { public void moveZeroes(int[] nums) { for (int i = 0,j = 0;i Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-12-15 18:05:37 "},"leetcode/344.反转字符串.html":{"url":"leetcode/344.反转字符串.html","title":"344.反转字符串.md","keywords":"","body":"344.反转字符串 难度 简单 题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 示例 示例 1： 输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例 2： 输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 提示： 1 s[i] 都是 ASCII 码表中的可打印字符 解题思路 创建时间： 2021年12月21日10:09:16 解法： 双指针： 左指针从0位置开始，右指针从尾部开始，左右指针值互换 复杂度分析 时间复杂度：O(N)，其中 N为字符数组的长度。一共执行了 N/2次的交换。 空间复杂度：O(1)。只使用了常数空间来存放若干变量。 程序逻辑 1.左指针位置为0，右指针为字符串末尾，交换数组长度一半，交换一次左指针右移一位，右指针左移一位 2.左右指针值互换 代码 class Solution { public void reverseString(char[] s) { for (int i = 0, j = s.length -1; i Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-12-21 10:21:20 "},"leetcode/557.反转字符串中的单词 III.html":{"url":"leetcode/557.反转字符串中的单词 III.html","title":"557.反转字符串中的单词 III.md","keywords":"","body":"557.反转字符串中的单词 III 难度 简单 题目 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例： 输入：\"Let's take LeetCode contest\" 输出：\"s'teL ekat edoCteeL tsetnoc\" 提示： 在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格 解题思路 创建时间： 2021年12月21日15:45:16 解法： 双指针： 切割字符串为字符串数组，每个字符串转换为字符数组，每个字符数组做左右指针交换，左右指针交换字符值，StringBuffer拼接转换完的字符数组，在拼接上空格，去掉多余空格 复杂度分析 时间复杂度：O(N)，其中 N为字符串的长度。原字符串中的每个字符都会在 O(1)的时间内放入新字符串中。 空间复杂度：O(N)。我们开辟了与原字符串等大的空间。 程序逻辑 1.按照空格切割字符串为字符串数组，声明StringBuffer拼接置换后的字符数组 2.循环遍历字符串数组 3.字符串转换为字符数组，循环遍历字符数组，前后置换字符，使原始字符顺序颠倒 4.StringBuffer拼接置换后的字符数组，拼接字符数组后的空格 5.返回StringBuffer去除最后一位多余空格的字符串 代码 class Solution { public String reverseWords(String s) { String[] strings = s.split(\" \"); StringBuffer sb = new StringBuffer(); for (int i = 0; i Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-12-21 17:51:50 "},"leetcode/704.二分查找.html":{"url":"leetcode/704.二分查找.html","title":"704.二分查找","keywords":"","body":"704.二分查找 题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 1.你可以假设 nums 中的所有元素是不重复的。 2.n 将在 [1, 10000]之间。 3.nums 的每个元素都将在 [-9999, 9999]之间。 解题思路 2021年11月30日14:57:28 解法1： 暴力解法，for循环找到相等返回下标，找不到返回-1。 时间复杂度是 O(n)，其中n是数组长度，beats 30%。 解法2： 二分查找： 设置左右边界，二分取中间值和目标值比较，如果等于目标值返回中间值下标值，如果目标值大于中间值，左边界右移到中间值加1位置，反之右边界左移到中间值-1位置，当左边界小于右边界时，说明数组中没有目标值，返回-1 时间复杂度 O(logn)，其中n是数组长度，beats 100%。 程序逻辑 1.设置初始左右边界为0，数组长度 2.设置中间值下标为右边界减去左边界除2加上左边界 3.通过中间值下标取出中间值 4.目标值和中间值比较 1)相等，返回目标值下标 2)目标值大于中间值，左边界等于中间值下标+1 3)目标值小于中间值，右边界等于中间值下标-1 5.左边界小于右边界还找不到目标值时，返回-1 代码 class Solution { public int search(int[] nums, int target) { int left = 0,right=nums.length-1; while(left num){ left = mid + 1; }else{ right = mid - 1; } } return -1; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2021-11-30 16:48:41 "},"leetcode/977.有序数组的平方.html":{"url":"leetcode/977.有序数组的平方.html","title":"977.有序数组的平方","keywords":"","body":"1446.连续字符](https://leetcode-cn.com/problems/consecutive-characters/) 难度 简单 题目 给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。 请你返回字符串的能量。 示例 示例 1： 输入：s = \"leetcode\" 输出：2 解释：子字符串 \"ee\" 长度为 2 ，只包含字符 'e' 。 示例 2： 输入：s = \"abbcccddddeeeeedcba\" 输出：5 解释：子字符串 \"eeeee\" 长度为 5 ，只包含字符 'e' 。 示例 3： 输入：s = \"triplepillooooow\" 输出：5 示例 4： 输入：s = \"hooraaaaaaaaaaay\" 输出：11 示例 5： 输入：s = \"tourist\" 输出：1 提示： 1 s 只包含小写英文字母。 解题思路 创建时间： 2021年12月22日18:00:27 解法： 循环遍历： 增加占位数组，最大值计数器，占位数组默认值为1，循环遍历字符串，如果字符后一位等于前一位则临时变量等于占位数值，临时变量和最大值计数器比较，不相等对应字符占位符重置为1 复杂度分析 时间复杂度：O(n)，其中 n是字符串 s的长度。遍历一次 s的时间复杂度为 O(n)。 空间复杂度：O(n)。其中n为占位数组长度26。 程序逻辑 1.获取原数组长度为n 2.声明新数组长度为n 3.循环中声明左指针为0，右指针为n-1，新数组填充下标为n-1，循环条件为左指针小于等于右指针 4.判断左指针下标数值乘积是否小于右指针下标数值乘积 左指针下标乘积大于右指针下标数值乘积，新数组填充为左下标数值乘积 左指针下标乘积小于右指针下标数值乘积，新数组填充为右下标数值乘积 5.新数组填充一次左移一位 代码 class Solution { public int[] sortedSquares(int[] A) { int n = A.length; int[] B = new int[n]; for (int i = 0,j = n - 1,index = n - 1;i A[j] * A[j]){ B[index] = A[i] * A[i]; i++; }else{ B[index] = A[j] * A[j]; j--; } index--; } return B; } } Copyright © 郑加彬 2021 all right reserved，powered by Gitbook修订时间： 2022-01-07 10:34:46 "}}